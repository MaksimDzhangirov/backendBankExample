# Запускаем миграции БД непосредственно внутри Golang кода

[Оригинал](https://www.youtube.com/watch?v=TG43cMpaxlI)

Всем привет, рад вас снова видеть на мастер-классе по бэкенду. Сегодня 
мы вернемся к старой теме: запуск миграций БД. Но на этот раз мы сделаем это 
не так, как делали раньше. Если вы ещё помните, в лекции 25 мы узнали, как
использовать `docker-compose` для запуска базы данных и бекэнд сервера 
с помощью одной единственной команды. И на той лекции нам нужно было 
загрузить бинарник `migrate` в образ Docker, а затем использовать 
его для запуска миграций БД внутри файла `start.sh` непосредственно 
перед запуском сервера. На тот момент всё работало как надо. Однако недавно 
я обнаружил, что этот способ больше не работает как мы ожидаем.

## Проблема при выполнении миграций БД

Позвольте мне показать вам, запустив

```shell
docker-compose up
```

в терминале.

![](../images/part48/1.png)

Как видите, API служба `simple-bank` не смогла запустить на этот раз и в
сообщении об ошибке говорится, что она не может подключиться к базе данных 
по этому IP-адресу `localhost`. Странно, потому что в файле 
`docker-compose.yaml` мы заменили переменную окружения `DB_SOURCE` URL-адресом,
указывающим на Postgres контейнер. Значит, он должен подключаться к Postgres
контейнеру, а не к `localhost`, верно?

Ну да, но давайте взглянем на файл `start.sh`. Здесь непосредственно 
перед запуском миграции прописана команда `source`, которая перезагружает 
переменные окружения из файла `app.env`. Вот почему значение переменной 
`DB_SOURCE`, которое мы задали в файле `docker-compose`, было заменено
значением из файла `app.env`, которое указывает на `localhost`, а не на
Postgres контейнер как мы хотели. Но почему?

На 25-й лекции все работало хорошо, не так ли? Что изменилось после этого?
Что ж, если мы посмотрим на историю изменений Git для строки

```shell
source /app/app.env
```

перейдя по этой ссылке, мы увидим, что команда `source` была добавлена 
позже.

![](../images/part48/2.png)

В истории коммитов нашего GitHub репозитория, мы видим, что этот коммит 
был отправлен на GitHub, когда мы пытались развернуть наше приложение в
продакшен среде. И если я правильно помню, это изменение было сделано на 
лекции 29, поскольку мы хотели, чтобы при проведении миграции происходило
подключение по URL-адресу продакшен базы данных, который хранился в 
файле `app.env`, а не в переменной окружения продакшена.

![](../images/part48/3.png)

![](../images/part48/4.png)

Вот почему команда `migrate` не смогла получить правильное значение 
`DB_SOURCE`, и нам пришлось добавить команду `source`, задав переменные
окружения в файле `app.env`.

Но изменение в продакшене не должно приводить к тому, что мы не можем
запустить всё локально, не так ли?

Итак, как мы можем это исправить?

## Решение проблемы

Что ж, проблема возникает из-за команды `source`, поэтому, если мы сможем 
избавиться от неё, но при этом запустить миграцию в продакшен среде, тогда 
это будет идеально. Обратите внимание, что как только мы запустим Golang 
API сервер, он загрузит все переменные из файла `app.env`,

```go
	config, err := util.LoadConfig(".")
	if err != nil {
		log.Fatal("cannot load config:", err)
	}
```

Поэтому, если мы сможем запустить миграцию здесь, у неё будет 
правильное значение `DB_SOURCE`.

```go
func main() {
    ...
	conn, err := sql.Open(config.DBDriver, config.DBSource)
	if err != nil {
		log.Fatal("cannot connect to db:", err)
	}

	// run db migration
	
	store := db.NewStore(conn)
	...
}
```

Это означает, что мы должны выполнить миграцию БД внутри кода нашего
Golang сервера. И именно этим мы будем заниматься в этом видео.

Хорошо, сначала давайте удалим этот кусок кода, который запускает миграцию 
внутри файла `start.sh`.

```shell
echo "run db migration"
source /app/app.env
/app/migrate -path /app/migration -database "$DB_SOURCE" -verbose
```

Поскольку мы собираемся выполнять миграцию БД в Golang коде, больше не 
нужно загружать бинарник `migrate` в Docker образ, поэтому я удалю 
эти 2 команды из `Dockerfile`,

```dockerfile
RUN apk add curl
RUN curl -L https://github.com/golang-migrate/migrate/releases/download/v4.14.1/migrate.linux-amd64.tar.gz | tar xvz
```

а также эту команду, которая копирует бинарник `migrate` в финальный 
образ.

```dockerfile
COPY --from=builder /app/migrate.linux-amd64 /usr/bin/migrate
```

Итак, теперь наш `Dockerfile` намного проще, чем раньше. Мы даже можем 
удалить точку входа `start.sh`, если захотим, но я не хочу усложнять,
изменяя слишком много фрагментов одновременно, и, кроме того, это может 
быть хорошим примером по использованию точки входа Docker. Так что я пока 
оставлю её в коде.

Хорошо, теперь давайте вернемся к файлу `main.go` и добавим код для запуска
миграции БД!

Если мы обратимся к документации `golang-migrate` в его GiHub репозитории,
то найдём [раздел] (https://github.com/golang-migrate/migrate#use-in-your-go-project),
где показано как выполнить миграцию БД с помощью Golang.

По сути, нам нужно будет создать новый объект `migrate`, в который нужно 
будет передать путь к файлам миграции, а также URL-адрес сервера базы данных.
Но сначала давайте скопируем эту команду импорта пакета `migrate` и
вставим её в наш файл `main.go`.

```go
"github.com/golang-migrate/migrate/v4"
```

Затем я создам новую функцию под названием `runDBMigration()`. Эта функция
будет приминать URL-адрес миграции и адрес сервера БД в качестве входных 
данных.

```go
func runDBMigration(migrationURL string, dbSource string) {
	
}
```

Хорошо, теперь мы можем вызвать `runDBMigraion()` здесь,

```go
func main() {
	...
	conn, err := sql.Open(config.DBDriver, config.DBSource)
	if err != nil {
		log.Fatal("cannot connect to db:", err)
	}

	runDBMigration()

	store := db.NewStore(conn)
	...
}
```

непосредственно перед запуском серверов и после того как мы загрузили 
переменные окружения в объект `config`. Обратите внимание, что URL-адрес 
миграции должен указывать туда, где находятся файлы миграции на локальной
машине или удаленном хосте. В нашем случае это будет папка `migration` 
внутри Docker контейнера. Поскольку в `Dockerfile` есть команда для 
копирования всего содержимого папки `db/migration` в Docker образ.

```dockerfile
COPY db/migration ./migration
```

Чтобы расширить возможности его использования, я определю этот путь в 
переменной окружения. Итак, внутри файла `app.env` добавим переменную 
`MIGRATION_URL`. И, как вы уже видели в документации, там используется
обозначение "github", чтобы указать, что файлы нужно искать на удалённом
GitHub сервере. Но в нашем случае вместо этого мы будем использовать 
локальную файловую систему, поэтому нам следует использовать обозначение 
"file" и путь `db/migration`.

```
MIGRATION_URL=file://db/migration
```

Хорошо, теперь мы должны добавить эту новую переменную в структуру
`Config`, поэтому я продублирую эту строку,

```go
DBSource             string        `mapstructure:"DB_SOURCE"`
```

и изменю дескриптор `mapstructure`, а также название поля на
Migration Url.

```go
MigrationURL         string        `mapstructure:"MIGRATION_URL"`
```

Хорошо, теперь давайте вернёмся к файлу `main.go`. Здесь мы передадим 
`config.MigrationUrl` и `config.DBSource` в функцию `runDBMigration()`.

```go
runDBMigration(config.MigrationURL, config.DBSource)
```

Затем в этой функции мы вызовем функцию `migrate.New()` и передадим эти два
входных параметра.

```go
func runDBMigration(migrationURL string, dbSource string) {
	migrate.New(migrationURL, dbSource)
}
```

Теперь, если мы попытаемся увидеть реализацию этой функции, Visual Studio 
Code не выдаст никаких подсказок. Причина в том, что я не ещё установил этот
пакет

```go
"github.com/golang-migrate/migrate/v4"
```

на свой локальный компьютер. И здесь под оператором `import` видна волнистая, 
предупреждающая об этом, линия.

![](../images/part48/5.png)

Чтобы избавиться от неё, давайте откроем терминал, остановим сервер и 
запустим

```shell
go mod tidy
```

Теперь предупреждающая волнистая строка исчезла и мы увидим документацию к
функции `migrate.New()`. Как показано на рисунке, она вернёт объект миграции
и ошибку.

![](../images/part48/6.png)

Поэтому мы должны проверить не равна ли ошибка `nil`. В этом случае мы пишем
сообщение в лог: "cannot create a new migrate instance" («невозможно создать 
новый экземпляр миграции») и завершаем работу приложения. В противном случае
мы вызовем `migrate.Up()` для запуска всех файлов миграций `up`.

```go
func runDBMigration(migrationURL string, dbSource string) {
    migration, err := migrate.New(migrationURL, dbSource)
    if err != nil {
        log.Fatal("cannot create a new migrate instance")
    }
    
    migration.Up()
}
```

Эта функция также вернет ошибку, поэтому мы должны проверить, равна ли она 
`nil` или нет. Если ошибка не `nil` мы запишем другое сообщение в лог:
"failed to run migrate up" («не удалось выполнить миграции up») и завершим 
работу приложения.

```go
func runDBMigration(migrationURL string, dbSource string) {
	...
	if err = migration.Up(); err != nil {
		log.Fatal("failed to run migrate up:", err)
	}
}
```

И добавим исходную ошибку в конец сообщения. Кстати, давайте добавим 
исходную ошибку и в конец предыдущего сообщения в лог.

```go
log.Fatal("cannot create a new migrate instance:", err)
```

Хорошо, тогда в конце функции, если ошибок не возникло, мы запишем сообщение
в лог, информирующее, что: "db migrated successfully" («миграции БД успешно 
выполнены»).

```go
log.Println("db migrated successfully")
```

И на этом по сути всё.

Давайте протестируем работу функции!

В терминале я проверю, запущен ли Postgres контейнер или нет.

```shell
docker ps
```

Если ещё нет, давайте запустим его

```shell
docker start postgres12
```

Теперь мы выполнив

```shell
make server
```

ожидаем, что миграции БД успешно отработают.

![](../images/part48/7.png)

Но похоже, что когда сервер пытается это сделать, он не может создать 
новый экземпляр `migrate` из-за этой ошибки: "unknown driver file
(forgotten import?)" («неизвестный драйвер file (забыли его импортировать?)»).

Итак, давайте снова обратимся к документации `migrate`.

Вот, в этом примере,

```go
import (
    "github.com/golang-migrate/migrate/v4"
    _ "github.com/golang-migrate/migrate/v4/database/postgres"
    _ "github.com/golang-migrate/migrate/v4/source/github"
)

func main() {
    m, err := migrate.New(
        "github://mattes:personal-access-token@mattes/migrate_test",
        "postgres://localhost:5432/database?sslmode=enable")
    m.Steps(2)
}
```

мы видим, что существует команда для импорта подпакета `source/github`
модуля `migrate`.

Итак, давайте скопируем эту команду, вставим её в список импорта нашего
файла `main.go` и изменим имя подпакета с "github" на "file"

```go
_ "github.com/golang-migrate/migrate/v4/source/file"
```

поскольку наши файлы миграции находятся в локальной файловой системе.

OK, готово!

Давайте попробуем снова запустить

```shell
make server
```

в терминале.

![](../images/part48/8.png)

Мы по-прежнему получили ошибку, но на этот раз она другая: "unknown driver
postgresql (forgotten import?)" («неизвестный драйвер postgresql (забыли 
его импортировать?)»).

Обратившись к документации ещё раз, мы увидим, что должны добавить еще один 
пустой импорт, который указывает на подпакет `database/postgres` модуля 
`migrate`. Итак, давайте скопируем и вставим его в наш файл `main.go`, как 
только что делали выше.

```go
_ "github.com/golang-migrate/migrate/v4/database/postgres"
```

Хорошо, теперь я почти уверен, что это должно решить проблему.

Попробуем снова запустить сервер в терминале!

![](../images/part48/9.png)

О нет, всё равно возникла ошибка! Но, к счастью, на этот раз ошибка отличается
от предыдущих. В ней говорится: "failed to run migrate up: no change" 
(«не удалось выполнить миграции up: нет новых изменений»). Таким образом,
этап создания объекта `migrate` успешно пройден и ошибка возникает 
только при запуске `migration.Up()`. И на самом деле это не ошибка вовсе,
так как в ней говорится об отсутствии новых изменений. Это означает, что 
новых изменений в структуре БД нет. Я не знаю, почему возвращается ошибка
в этом случае, но поскольку пакет уже был реализован таким образом, давайте
пока оставим всё как есть, так как мы можем легко разобраться с ней, 
проверив, что ошибка не равна `migrate.ErrNoChange` здесь,

```go
func runDBMigration(migrationURL string, dbSource string) {
	...
	if err = migration.Up(); err != nil && err != migrate.ErrNoChange {
		log.Fatal("failed to run migrate up:", err)
	}
	...
}
```

прежде чем отправить сообщение в лог и завершить работу приложения.

Хорошо, давайте перезапустим сервер ещё раз!

Ура, на этот раз миграции БД успешно выполнены, gRPC и HTTP сервера 
запущены и работают без проблем. 

![](../images/part48/10.png)

Превосходно!

Теперь прежде чем мы закончим, я хочу убедиться, что всё действительно 
работает без ошибок, если мы запустим весь процесс с «нуля», используя
`docker-compose`.

Поэтому сначала давайте остановим контейнер `postgress12`

```shell
docker stop postgres12
```

и выполним в терминале

```shell
docker-compose down
```

чтобы удалить все существующие сервисы.

Просмотрите существующие Docker образы

```shell
docker images
```

и удалите старый образ `simplebank_api`.

```shell
docker rmi simplebank_api
```

Хорошо, теперь после того как старый образ удалён, я запущу

```shell
docker compose up
```

Она заново соберёт Docker образ, затем запустит базу данных Postgres,
а затем попытается запустить `simplebank-api`.

![](../images/part48/11.png)

Но как видно на рисунке, при запуске произошла ошибка с сообщением:
"open app/db/migration: no such file or directory" («открытие 
приложения/БД/миграции: нет такого файла или каталога»). Это означает, что 
`golang-migrate` не может найти файлы миграции внутри контейнера.

Так что же произошло? Давайте просмотрим `Dockerfile`.

```dockerfile
# Builds stage
FROM golang:1.16-alpine3.13 AS builder
WORKDIR /app
COPY . .
RUN go build -o main main.go

# Run stage
FROM alpine3.13
WORKDIR /app
COPY --from=builder /app/main .
COPY app.env .
COPY start.sh .
COPY wait-for.sh .
COPY db/migration ./migration

EXPOSE 8080
CMD ["/app/main"]
ENTRYPOINT ["/app/start.sh"]
```

Смогли ли вы обнаружить ошибку, которую я допустил? На самом деле, её 
довольно легко увидеть, не так ли? Здесь,

```dockerfile
COPY db/migration ./migration
```

мы копируем папку `db/migration` в папку `migration` внутри образа, в то
время как вместо этого нужно копировать файлы в `db/migration`.

```dockerfile
COPY db/migration ./db/migration
```

Исправив это, я на 100% уверен, что на этот раз все будет работать без 
ошибок.

Давайте попробуем!

В терминале я выполню

```shell
docker compose down
```

затем удалю текущий образ `simplebank_api`

```shell
docker rmi simplebank_api
```

и запущу

```shell
docker-compose up
```

опять.

![](../images/part48/12.png)

Хорошо, на этот раз миграции базы данных успешно выполнены, а серверы 
запущены и работают, как мы и ожидали. Превосходно!

Мы можем попробовать отправить запрос на создание пользователя с помощью 
Postman.

![](../images/part48/13.png)

![](../images/part48/14.png)

Он действительно успешно выполнится.

На этом мы завершим сегодняшнюю лекцию о том как выполнить миграции БД,
используя Golang.

Я надеюсь, что вы узнали из неё что-то полезное и интересное для себя!
Большое спасибо за время, потраченное на чтение! Желаю Вам получать 
удовольствие от обучения и до встречи на следующей лекции!
